# blueprint: bundle all prod deps' .d.ts

---

## 1. overview

### .what

migrate build from `tsc` to `tsdown` with `dts.resolve` to inline all production dependency types into the output `.d.ts` file.

### .why

solve TS2742 transitive dependency errors for consumers:

```
simple-log-methods -> as-procedure -> rhachet -> rhachet-roles-brain
                                                  ↓
                                          TS2742 error!
```

consumers cannot resolve types from `simple-log-methods` because:
1. it's not in their direct dependencies
2. pnpm doesn't hoist transitive deps
3. typescript's heuristic symlink discovery fails

### .outcome

```ts
// before bundle:
import { LogMethods } from 'simple-log-methods';
export interface Context { log: LogMethods; }

// after bundle:
interface LogMethods { /* inlined */ }
export interface Context { log: LogMethods; }
```

---

## 2. forwarded types declaration

### .what

add a `forwarded` field to `package.json` that lists dependencies whose types are re-exported and need bundled into the output `.d.ts`.

### .why

- **explicit > magic** — maintainers declare intent, no detection or source analysis needed
- **familiar pattern** — maintainers already manage `dependencies`, `devDependencies`, `peerDependencies`
- **clear contract** — tsdown reads from `forwarded` to populate `dts.resolve`

### package.json addition

```json
{
  "forwarded": [
    "domain-glossary-procedure",
    "simple-log-methods"
  ]
}
```

### what qualifies as "forwarded"

| pattern | forwarded? | reason |
|---------|------------|--------|
| `export * from 'pkg'` | ✅ yes | all types exposed to consumers |
| `export { Type } from 'pkg'` | ✅ yes | specific types exposed |
| `export type { Type } from 'pkg'` | ✅ yes | type-only re-export |
| `import { fn } from 'pkg'` (used internally) | ❌ no | not exposed in public api |
| types used in function signatures | ⚠️ maybe | if consumer must reference them |

### for as-procedure

from `src/index.ts`:

```ts
export * from 'domain-glossary-procedure'; // ← forwarded
export * from 'simple-log-methods';        // ← forwarded
```

other deps (`helpful-errors`, `serde-fns`, `type-fns`) are used internally but not re-exported via `export *`.

---

## 3. implementation phases

### phase 0: prep

#### 0.1 add tsdown as dev dependency

```sh
pnpm add -D tsdown
```

#### 0.2 add `forwarded` field to package.json

```json
{
  "forwarded": [
    "domain-glossary-procedure",
    "simple-log-methods"
  ]
}
```

maintainers must update this list when they add/remove `export * from 'pkg'` patterns.

#### 0.3 audit current exports for explicit return types

tsdown with `isolatedDeclarations` requires explicit return types on all exports.

files to audit:
- `src/domain.operations/asProcedure.ts`
- `src/domain.operations/withExpectOutput.ts`
- `src/domain.operations/withExpectOutkey.ts`
- `src/domain.operations/getCallerFileName.ts`
- `src/domain.operations/inferProcedureName.ts`
- `src/domain.objects/HasName.ts`

### phase 1: tsdown configuration

#### 1.1 create `tsdown.config.ts`

```ts
import { defineConfig } from 'tsdown';
import pkg from './package.json';

/**
 * .what = tsdown build config with forwarded types bundle
 * .why = inlines re-exported dependency types to solve TS2742
 */
export default defineConfig({
  entry: ['src/index.ts'],
  outDir: 'dist',
  format: ['esm'],
  dts: {
    resolve: pkg.forwarded ?? [], // read from package.json.forwarded
    resolver: 'tsc', // more compatible for complex type re-exports
  },
  clean: true,
});
```

note: tsdown.config.ts reads `forwarded` from package.json — no hardcoded list.

#### 1.2 update `package.json` scripts

```json
{
  "scripts": {
    "build:compile": "tsdown",
    "build": "npm run build:clean && npm run build:compile && npm run build:complete --if-present"
  }
}
```

#### 1.3 update `package.json` exports

```json
{
  "main": "dist/index.js",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  }
}
```

### phase 2: explicit return types

add explicit return types to all exported functions (required for `isolatedDeclarations`):

#### 2.1 `asProcedure.ts`

```ts
export const asProcedure = <TProcedure extends Procedure>(
  logic: HasContextLogTrail<TProcedure>,
): TProcedure => { ... }
```

status: ✓ already has explicit return type

#### 2.2 `withExpectOutput.ts`

```ts
export const withExpectOutput = <...>(
  logic: TLogic,
): WithExpectOutput<TLogic> => { ... }
```

status: ✓ already has explicit return type

#### 2.3 audit rest of files

scan all exports for inferred return types and add explicit annotations.

### phase 3: validation

#### 3.1 run build

```sh
npm run build
```

#### 3.2 verify bundled types

inspect `dist/index.d.ts` to confirm:
- `LogMethods` interface is inlined (not imported)
- `Procedure` type is inlined (not imported)
- all re-exported types are present
- no external imports for bundled deps

---

## 4. test coverage requirements

### 4.1 unit tests

| test | location | what it tests |
|------|----------|---------------|
| explicit return types | type-check at build | all exports have valid types |
| prior unit tests | `*.test.ts` | prior behavior preserved |

prior tests:
- `withExpectOutput.test.ts` ✓
- `withExpectOutkey.test.ts` ✓

no new unit tests needed — this is a build-config change, not a logic change.

### 4.2 acceptance tests: bundled types verification

create: `src/blackbox/dts-bundle.acceptance.test.ts`

blackbox tests run against `dist/` output — the only scope appropriate to verify bundled types.

```ts
import { given, when, then } from 'test-fns';
import * as fs from 'fs/promises';
import * as path from 'path';
import pkg from '../../package.json';

describe('dts bundle', () => {
  given('the built dist/index.d.ts file', () => {
    const dtsPath = path.join(__dirname, '../../dist/index.d.ts');

    when('inspected for forwarded deps', () => {
      // dynamically test each forwarded dep from package.json
      (pkg.forwarded ?? []).forEach((dep: string) => {
        then(`should not import from ${dep}`, async () => {
          const dts = await fs.readFile(dtsPath, 'utf-8');
          expect(dts).not.toContain(`from '${dep}'`);
          expect(dts).not.toContain(`from "${dep}"`);
        });
      });

      then('should contain inlined LogMethods interface', async () => {
        const dts = await fs.readFile(dtsPath, 'utf-8');
        expect(dts).toContain('LogMethods');
      });

      then('should contain inlined Procedure type', async () => {
        const dts = await fs.readFile(dtsPath, 'utf-8');
        expect(dts).toContain('Procedure');
      });
    });
  });
});
```

note: test reads `forwarded` from package.json — tests stay in sync with config.

---

## 5. tradeoffs acknowledged

### 5.1 declaration maps are lost

when types are bundled, `.d.ts.map` files are not rolled up:
- "go to definition" navigates to bundled `.d.ts` instead of original source
- this is a known limitation across all dts bundle tools

**mitigation**: none available. the portability gain outweighs this limitation.

### 5.2 package size increase

bundled types add ~marginal size:
- type declarations are text-only and compress well
- consumers already need these types — bundled just consolidates

**mitigation**: none needed. size increase is negligible.

---

## 6. rollback plan

if issues arise:

1. revert `package.json` scripts to use `tsc`
2. remove `tsdown.config.ts`
3. remove `tsdown` dev dependency
4. the original `tsconfig.build.json` is unchanged

---

## 7. success criteria

| criterion | verification |
|-----------|--------------|
| build passes | `npm run build` succeeds |
| types pass | `npm run test:types` succeeds |
| unit tests pass | `npm run test:unit` succeeds |
| no external imports in .d.ts | `npm run test:acceptance` passes |
| publish works | `npm pack` produces valid tarball |

---

## 8. future considerations

### 8.1 isolated declarations performance

once explicit return types are added, consider to enable `isolatedDeclarations: true` in tsconfig for 40x faster dts generation via oxc.

### 8.2 lint rule for forwarded consistency

a future lint rule could verify that:
- every `export * from 'pkg'` in entry files has `pkg` in `forwarded`
- every entry in `forwarded` is also in `dependencies`

this would catch drift between source re-exports and the `forwarded` declaration.

---

## 9. file changes summary

| file | action |
|------|--------|
| `package.json` | add `forwarded` field, update scripts, add tsdown dep |
| `tsdown.config.ts` | create (reads from `package.json.forwarded`) |
| `src/blackbox/dts-bundle.acceptance.test.ts` | create |
| `src/**/*.ts` | add explicit return types if absent |

---

## 10. references

- [tsdown documentation](https://tsdown.dev/guide/)
- [tsdown dts options](https://tsdown.dev/options/dts)
- [microsoft/TypeScript#42873](https://github.com/microsoft/TypeScript/issues/42873) - TS2742 type portability
- [.agent/repo=.this/role=any/briefs/tool.tsdown.dts-bundle.md](../../.agent/repo=.this/role=any/briefs/tool.tsdown.dts-bundle.md)
- [.behavior/v2026_01_13.bundle-all-prod-deps/3.1.research.claims._.v1.i1.md](./3.1.research.claims._.v1.i1.md)
